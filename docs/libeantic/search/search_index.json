{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"e-antic : Computing with Real Embedded Number Fields \u00b6 e-antic is a C library for exact computation with real embedded algebraic numbers. It also offers C++ and Python interfaces. The C library is built on top of FLINT , Arb and antic and follows the same naming conventions. The main focus of e-antic is on efficiency. For a more versatile C library for exact real numbers computations we recommend Calcium by Fredrik Johansson. The development of e-antic is coordinated on github . Installation \u00b6 The preferred way to install e-antic is to use your package manager (e.g. apt-get on Debian or Ubuntu, pacman on Arch Linux, brew on MacOS, etc). See repology for e-antic . The following describe alternative ways of installing e-antic. Install with Conda Build from Source Conda Environment to Build from Source C Library \u00b6 Tour of the C Interface Number Fields renf.h Number Field Elements renf_elem.h The following headers extend FLINT . They should not be considered as part of the e-antic API and will be ported to FLINT eventually. Rational Polynomials fmpq_poly_extra.h Integral Polynomials fmpz_poly_extra.h C++ Interface \u00b6 Tour of the C++ Interface Number Fields renf_class.hpp Number Field Elements renf_elem_class.hpp Python Interface \u00b6 The Python interface relies on cppyy exposing automatic bindings to the C++ interface. The documentation of the Python interface can be found here .","title":"Home"},{"location":"#e-antic-computing-with-real-embedded-number-fields","text":"e-antic is a C library for exact computation with real embedded algebraic numbers. It also offers C++ and Python interfaces. The C library is built on top of FLINT , Arb and antic and follows the same naming conventions. The main focus of e-antic is on efficiency. For a more versatile C library for exact real numbers computations we recommend Calcium by Fredrik Johansson. The development of e-antic is coordinated on github .","title":"e-antic : Computing with Real Embedded Number Fields"},{"location":"#installation","text":"The preferred way to install e-antic is to use your package manager (e.g. apt-get on Debian or Ubuntu, pacman on Arch Linux, brew on MacOS, etc). See repology for e-antic . The following describe alternative ways of installing e-antic. Install with Conda Build from Source Conda Environment to Build from Source","title":"Installation"},{"location":"#c-library","text":"Tour of the C Interface Number Fields renf.h Number Field Elements renf_elem.h The following headers extend FLINT . They should not be considered as part of the e-antic API and will be ported to FLINT eventually. Rational Polynomials fmpq_poly_extra.h Integral Polynomials fmpz_poly_extra.h","title":"C Library"},{"location":"#c-interface","text":"Tour of the C++ Interface Number Fields renf_class.hpp Number Field Elements renf_elem_class.hpp","title":"C++ Interface"},{"location":"#python-interface","text":"The Python interface relies on cppyy exposing automatic bindings to the C++ interface. The documentation of the Python interface can be found here .","title":"Python Interface"},{"location":"doc_cereal_hpp/","text":"cereal.hpp \u00b6","title":"cereal.hpp"},{"location":"doc_cereal_hpp/#cerealhpp","text":"","title":"cereal.hpp"},{"location":"doc_config_h/","text":"config.h \u00b6","title":"config.h"},{"location":"doc_config_h/#configh","text":"","title":"config.h"},{"location":"doc_cppyy_hpp/","text":"cppyy.hpp \u00b6","title":"cppyy.hpp"},{"location":"doc_cppyy_hpp/#cppyyhpp","text":"","title":"cppyy.hpp"},{"location":"doc_e_antic_h/","text":"e-antic.h \u00b6","title":"e-antic.h"},{"location":"doc_e_antic_h/#e-antich","text":"","title":"e-antic.h"},{"location":"doc_e_antic_hpp/","text":"e-antic.hpp \u00b6","title":"e-antic.hpp"},{"location":"doc_e_antic_hpp/#e-antichpp","text":"","title":"e-antic.hpp"},{"location":"doc_fmpq_poly_extra_h/","text":"fmpq_poly_extra.h \u2014 Flint rational polynomials utilities \u00b6 int fmpq_poly_set_str_pretty(fmpq_poly_t p, char* s, char* var) \u00b6 Set the polynomial p from the string s using var as variable name void fmpq_poly_evaluate_arb(arb_t b, const fmpq_poly_t pol, const arb_t a, slong prec) \u00b6 Evaluate the polynomial pol at the ball b void fmpq_poly_evaluate_arf(arf_t b, const fmpq_poly_t pol, const arf_t a, slong prec) \u00b6 Evaluate the polynomial pol at the ball b int fmpq_poly_check_unique_real_root(const fmpq_poly_t pol, const arb_t a, slong prec) \u00b6 Return 1 if it is possible to check with precision prec whether the interval a encloses a unique root of pol","title":"fmpq\\_poly\\_extra.h \u2014 Flint rational polynomials utilities"},{"location":"doc_fmpq_poly_extra_h/#fmpq_poly_extrah-flint-rational-polynomials-utilities","text":"","title":"fmpq\u000295\u0003poly\u000295\u0003extra.h \u2014 Flint rational polynomials utilities"},{"location":"doc_fmpq_poly_extra_h/#int-fmpq_poly_set_str_prettyfmpq_poly_t-p-char-s-char-var","text":"Set the polynomial p from the string s using var as variable name","title":"int fmpq_poly_set_str_pretty(fmpq_poly_t p, char* s, char* var)"},{"location":"doc_fmpq_poly_extra_h/#void-fmpq_poly_evaluate_arbarb_t-b-const-fmpq_poly_t-pol-const-arb_t-a-slong-prec","text":"Evaluate the polynomial pol at the ball b","title":"void fmpq_poly_evaluate_arb(arb_t b, const fmpq_poly_t pol, const arb_t a, slong prec)"},{"location":"doc_fmpq_poly_extra_h/#void-fmpq_poly_evaluate_arfarf_t-b-const-fmpq_poly_t-pol-const-arf_t-a-slong-prec","text":"Evaluate the polynomial pol at the ball b","title":"void fmpq_poly_evaluate_arf(arf_t b, const fmpq_poly_t pol, const arf_t a, slong prec)"},{"location":"doc_fmpq_poly_extra_h/#int-fmpq_poly_check_unique_real_rootconst-fmpq_poly_t-pol-const-arb_t-a-slong-prec","text":"Return 1 if it is possible to check with precision prec whether the interval a encloses a unique root of pol","title":"int fmpq_poly_check_unique_real_root(const fmpq_poly_t pol, const arb_t a, slong prec)"},{"location":"doc_fmpz_poly_extra_h/","text":"fmpz_poly_extra.h \u2014 Flint integral polynomials utilities \u00b6 void _fmpz_poly_scale_0_1_fmpq(fmpz* pol, slong len, fmpq_t a, fmpq_t b) \u00b6 Precompose the polynomial pol by an affine transformation so that the interval [ a , b ] becomes the interval [0,1] void fmpz_poly_randtest_irreducible(fmpz_poly_t p, flint_rand_t state, slong len, ulong bits) \u00b6 Set p to be a random irreducible polynomial int fmpz_poly_set_str_pretty(fmpz_poly_t p, char* s, char* var) \u00b6 Set the polynomial p from the string s using var as variable name int _fmpz_poly_has_real_root(fmpz* pol, slong len) \u00b6 Return 1 if the polynomial pol has a real root and 0 otherwise slong fmpz_poly_positive_root_upper_bound_2exp(const fmpz_poly_t pol) \u00b6 Return an upper bound on the bitsize of largest real root of pol . slong _fmpz_poly_positive_root_upper_bound_2exp(fmpz* pol, slong len) \u00b6 Return an upper bound on the bitsize of largest real root of (pol, len) . slong fmpz_poly_num_real_roots_upper_bound(fmpz_poly_t pol) \u00b6 Return an upper bound on the number of real roots of the polynomial pol (currently using Descartes\u2019 rule of sign). slong _fmpz_poly_descartes_bound_0_1(fmpz* p, slong len, slong bound) \u00b6 Return an upper bound on the number of real roots between 0 and 1 of the polynomial (p, len) using Descartes\u2019 rule of sign. If the result is larger than bound then WORD_MAX is returned. void _fmpz_poly_isolate_real_roots_0_1_vca(fmpq* exact_roots, slong* n_exact_roots, fmpz* c_array, slong* k_array, slong* n_intervals, fmpz* pol, slong len) \u00b6 Isolate the real roots of (pol, len) contained in the interval $(0, 1)$. The array exact_roots will be set by the exact dyadic roots found by the algorithm and n_exact_roots updated accordingly. The arrays c_array and k_array are set to be interval data that enclose the remaining roots and n_interval is updated accordingly. A data c = c_array + i and k = k_array[i] represents the open interval $(c 2^k, (c + 1) 2^k)$. void fmpz_poly_isolate_real_roots(fmpq* exact_roots, slong* n_exact, fmpz* c_array, slong* k_array, slong* n_interval, fmpz_poly_t pol) \u00b6 Isolate the real roots of pol . The array exact_roots will be set by the exact dyadic roots found by the algorithm and n_exact_roots updated accordingly. The arrays c_array and k_array are set to be interval data that enclose the remaining roots and n_interval is updated accordingly. A data c = c_array + i and k = k_array[i] represents the open interval $(c 2^k, (c + 1) 2^k)$. void fmpz_poly_abs(fmpz_poly_t res, fmpz_poly_t p) \u00b6 Set res to be the polynomial whose coefficients are the absolute values of the ones in p void _fmpz_poly_evaluate_arb(arb_t res, fmpz* pol, slong len, const arb_t a, slong prec) \u00b6 Evaluate the polynomial pol at the ball a and set result in res","title":"fmpz\\_poly\\_extra.h \u2014 Flint integral polynomials utilities"},{"location":"doc_fmpz_poly_extra_h/#fmpz_poly_extrah-flint-integral-polynomials-utilities","text":"","title":"fmpz\u000295\u0003poly\u000295\u0003extra.h \u2014 Flint integral polynomials utilities"},{"location":"doc_fmpz_poly_extra_h/#void-_fmpz_poly_scale_0_1_fmpqfmpz-pol-slong-len-fmpq_t-a-fmpq_t-b","text":"Precompose the polynomial pol by an affine transformation so that the interval [ a , b ] becomes the interval [0,1]","title":"void _fmpz_poly_scale_0_1_fmpq(fmpz* pol, slong len, fmpq_t a, fmpq_t b)"},{"location":"doc_fmpz_poly_extra_h/#void-fmpz_poly_randtest_irreduciblefmpz_poly_t-p-flint_rand_t-state-slong-len-ulong-bits","text":"Set p to be a random irreducible polynomial","title":"void fmpz_poly_randtest_irreducible(fmpz_poly_t p, flint_rand_t state, slong len, ulong bits)"},{"location":"doc_fmpz_poly_extra_h/#int-fmpz_poly_set_str_prettyfmpz_poly_t-p-char-s-char-var","text":"Set the polynomial p from the string s using var as variable name","title":"int fmpz_poly_set_str_pretty(fmpz_poly_t p, char* s, char* var)"},{"location":"doc_fmpz_poly_extra_h/#int-_fmpz_poly_has_real_rootfmpz-pol-slong-len","text":"Return 1 if the polynomial pol has a real root and 0 otherwise","title":"int _fmpz_poly_has_real_root(fmpz* pol, slong len)"},{"location":"doc_fmpz_poly_extra_h/#slong-fmpz_poly_positive_root_upper_bound_2expconst-fmpz_poly_t-pol","text":"Return an upper bound on the bitsize of largest real root of pol .","title":"slong fmpz_poly_positive_root_upper_bound_2exp(const fmpz_poly_t pol)"},{"location":"doc_fmpz_poly_extra_h/#slong-_fmpz_poly_positive_root_upper_bound_2expfmpz-pol-slong-len","text":"Return an upper bound on the bitsize of largest real root of (pol, len) .","title":"slong _fmpz_poly_positive_root_upper_bound_2exp(fmpz* pol, slong len)"},{"location":"doc_fmpz_poly_extra_h/#slong-fmpz_poly_num_real_roots_upper_boundfmpz_poly_t-pol","text":"Return an upper bound on the number of real roots of the polynomial pol (currently using Descartes\u2019 rule of sign).","title":"slong fmpz_poly_num_real_roots_upper_bound(fmpz_poly_t pol)"},{"location":"doc_fmpz_poly_extra_h/#slong-_fmpz_poly_descartes_bound_0_1fmpz-p-slong-len-slong-bound","text":"Return an upper bound on the number of real roots between 0 and 1 of the polynomial (p, len) using Descartes\u2019 rule of sign. If the result is larger than bound then WORD_MAX is returned.","title":"slong _fmpz_poly_descartes_bound_0_1(fmpz* p, slong len, slong bound)"},{"location":"doc_fmpz_poly_extra_h/#void-_fmpz_poly_isolate_real_roots_0_1_vcafmpq-exact_roots-slong-n_exact_roots-fmpz-c_array-slong-k_array-slong-n_intervals-fmpz-pol-slong-len","text":"Isolate the real roots of (pol, len) contained in the interval $(0, 1)$. The array exact_roots will be set by the exact dyadic roots found by the algorithm and n_exact_roots updated accordingly. The arrays c_array and k_array are set to be interval data that enclose the remaining roots and n_interval is updated accordingly. A data c = c_array + i and k = k_array[i] represents the open interval $(c 2^k, (c + 1) 2^k)$.","title":"void _fmpz_poly_isolate_real_roots_0_1_vca(fmpq* exact_roots, slong* n_exact_roots, fmpz* c_array, slong* k_array, slong* n_intervals, fmpz* pol, slong len)"},{"location":"doc_fmpz_poly_extra_h/#void-fmpz_poly_isolate_real_rootsfmpq-exact_roots-slong-n_exact-fmpz-c_array-slong-k_array-slong-n_interval-fmpz_poly_t-pol","text":"Isolate the real roots of pol . The array exact_roots will be set by the exact dyadic roots found by the algorithm and n_exact_roots updated accordingly. The arrays c_array and k_array are set to be interval data that enclose the remaining roots and n_interval is updated accordingly. A data c = c_array + i and k = k_array[i] represents the open interval $(c 2^k, (c + 1) 2^k)$.","title":"void fmpz_poly_isolate_real_roots(fmpq* exact_roots, slong* n_exact, fmpz* c_array, slong* k_array, slong* n_interval, fmpz_poly_t pol)"},{"location":"doc_fmpz_poly_extra_h/#void-fmpz_poly_absfmpz_poly_t-res-fmpz_poly_t-p","text":"Set res to be the polynomial whose coefficients are the absolute values of the ones in p","title":"void fmpz_poly_abs(fmpz_poly_t res, fmpz_poly_t p)"},{"location":"doc_fmpz_poly_extra_h/#void-_fmpz_poly_evaluate_arbarb_t-res-fmpz-pol-slong-len-const-arb_t-a-slong-prec","text":"Evaluate the polynomial pol at the ball a and set result in res","title":"void _fmpz_poly_evaluate_arb(arb_t res, fmpz* pol, slong len, const arb_t a, slong prec)"},{"location":"doc_forward_hpp/","text":"forward.hpp \u00b6","title":"forward.hpp"},{"location":"doc_forward_hpp/#forwardhpp","text":"","title":"forward.hpp"},{"location":"doc_local_h/","text":"local.h \u00b6","title":"local.h"},{"location":"doc_local_h/#localh","text":"","title":"local.h"},{"location":"doc_renf_class_hpp/","text":"renf_class.hpp \u2014 Real Embedded Number Fields \u00b6 Class renf_class \u00b6 A Real Embedded Number Field. All number fields are simple extensions of the rational numbers whose defining minimal polynomial has a real root. To create a number field, use one of the factory functions ; typically, by specifying the minimal polynomial of the number field and selecting a real root: #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); These factories return an intrusive pointer to a number field which takes care of reference counting, i.e., you do not need to worry about dangling references; any element of the number field keeps the number field itself alive. All number fields are unique. If you are familiar with SageMath, they are \u201cunique parents\u201d. If you create the same number field twice, you get a reference to the same field: #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto L = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.41 +/- 1\"); L->gen().parent() == *K // -> true &L->gen().parent() == &*K // -> true Number fields are hashable but not ordered, i.e., they can be used in containers such as std::unordered_set but not in std::set . const renf_class& make() \u00b6 Return the trivial number field obtained by adjoining a root of $x - 1$ to the rationals. boost::intrusive_ptr<const renf_class> make(const ::renf_t, const string& gen) \u00b6 Return the number field created from a ::renf_t , the C type underlying a renf_class . boost::intrusive_ptr<const renf_class> make(const string& minpoly, const string& gen, const string& emb, slong prec) \u00b6 Return the number field obtained by adjoining the root of minpoly which is approximately emb . #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"2*x^4 - 4\", \"x\", \"1 +/- 1\"); Parameter minpoly \u00b6 An irreducible polynomial in the variable gen . This minimal polynomial does not have to be totally real or monic. Parameter gen \u00b6 The name of the variable used in minpoly . Note that two fields that differ only in the name of the generator are treated as being distinct fields. Parameter emb \u00b6 An approximation of the root of minpoly . It makes no difference to what precision this approximation is provided but it must uniquely determine a single root of the polynomial. Parameter prec \u00b6 The default precision for all arithmetic. When performing arithmetic in this field, all operations are performed to that precision. When necessary, the precision is dynamically increased. This only affects the performance and inner workings of libeantic, the results of arithmetic operations and comparisons are not affected by this. boost::intrusive_ptr<const renf_class> make(const string& minpoly, const string& gen, const function<string (slong)> emb, slong prec) \u00b6 Return the number field obtained by adjoining the root of minpoly which is approximately emb . #include <e-antic/renf_class.hpp> #include <arb.h> #include <arf.h> const auto emb = [](slong prec) { arb_t emb; arb_init(emb); arb_sqrt_ui(emb, 2, prec); char* c_str = arb_get_str(emb, prec, ARB_STR_NO_RADIUS); std::string str(c_str); flint_free(c_str); arb_clear(emb); return str; }; auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", emb); Parameter minpoly \u00b6 An irreducible polynomial in the variable gen . This minimal polynomial does not have to be totally real or monic. Parameter gen \u00b6 The name of the variable used in minpoly . Note that two fields that differ only in the name of the generator are treated as being distinct fields. Parameter emb \u00b6 Creates approximations of the root of minpoly that is suitable for computations with precision prec . It makes no difference to what precision this approximation is provided but it must for a sufficiently large value of prec uniquely determine a single root of the polynomial; with increasing prec it should converge to the actual root. Parameter prec \u00b6 The default precision for all arithmetic. When performing arithmetic in this field, all operations are performed to that precision. When necessary, the precision is dynamically increased. This only affects the performance and inner workings of libeantic, the results of arithmetic operations and comparisons are not affected by this. slong degree() const \u00b6 Return the absolute degree of this number field. const renf_elem_class& zero() const \u00b6 Return the zero element of this number field. const renf_elem_class& one() const \u00b6 Return the one element of this number field. const renf_elem_class& gen() const \u00b6 Return the generator of this number field. #include <e-antic/renf_class.hpp> auto& K = eantic::renf_class::make(); std::cout << K.gen(); // -> 1 auto L = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.41 +/- 1\"); std::cout << L->gen(); // -> (x ~ 1.4142136) tuple<string, string, string, slong> construction() const \u00b6 Return the parameters (minpoly, gen, emb, prec) that can be used to construct this field with make . #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"2*x^4 - 4\", \"x\", \"1 +/- 1\"); auto construction = K->construction(); auto L = eantic::renf_class::make( std::get<0>(construction), std::get<1>(construction), std::get<2>(construction), std::get<3>(construction)); K == L // -> true friend bool operator==(const renf_class&, const renf_class&) \u00b6 Return whether two number fields are indistinguishable. #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1 +/- 1\"); auto L = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.41 +/- 0.1\"); K == L // -> true auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1 +/- 1\"); auto L = eantic::renf_class::make(\"2*x^2 - 4\", \"x\", \"1 +/- 1\"); K == L // -> false auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1 +/- 1\"); auto L = eantic::renf_class::make(\"y^2 - 2\", \"y\", \"1 +/- 1\"); K == L // -> false K != L // -> true const string& gen_name() const \u00b6 Return the name of the generator of this field. string to_string() const \u00b6 Return a human-readable representation of this field. #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"2*x^4 - 4\", \"x\", \"1 +/- 1\"); K->to_string() // -> NumberField(2*x^4 - 4, [1.18920711500272106671749997056 +/- 1.11e-30]) // There is also an operator<< which gives the same output. std::cout << *K; // -> NumberField(2*x^4 - 4, [1.18920711500272106671749997056 +/- 1.11e-30]) friend ostream& operator<<(ostream&, const renf_class&) \u00b6 Write a human-readable representation of this field to the output stream. add_lvalue_reference_t< ::renf_t> renf_t() const \u00b6 Return the underlying renf_t . We do not return a const renf_t since calls in the C API might need to modify it (e.g., to refine the stored embedding) even though they are morally const.","title":"renf_class - number fields"},{"location":"doc_renf_class_hpp/#renf_classhpp-real-embedded-number-fields","text":"","title":"renf\u000295\u0003class.hpp \u2014 Real Embedded Number Fields"},{"location":"doc_renf_class_hpp/#class-renf_class","text":"A Real Embedded Number Field. All number fields are simple extensions of the rational numbers whose defining minimal polynomial has a real root. To create a number field, use one of the factory functions ; typically, by specifying the minimal polynomial of the number field and selecting a real root: #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); These factories return an intrusive pointer to a number field which takes care of reference counting, i.e., you do not need to worry about dangling references; any element of the number field keeps the number field itself alive. All number fields are unique. If you are familiar with SageMath, they are \u201cunique parents\u201d. If you create the same number field twice, you get a reference to the same field: #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto L = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.41 +/- 1\"); L->gen().parent() == *K // -> true &L->gen().parent() == &*K // -> true Number fields are hashable but not ordered, i.e., they can be used in containers such as std::unordered_set but not in std::set .","title":"Class renf_class"},{"location":"doc_renf_class_hpp/#const-renf_class-make","text":"Return the trivial number field obtained by adjoining a root of $x - 1$ to the rationals.","title":"const renf_class&amp; make()"},{"location":"doc_renf_class_hpp/#boostintrusive_ptrconst-renf_class-makeconst-renf_t-const-string-gen","text":"Return the number field created from a ::renf_t , the C type underlying a renf_class .","title":"boost::intrusive_ptr&lt;const renf_class&gt; make(const ::renf_t, const string&amp; gen)"},{"location":"doc_renf_class_hpp/#boostintrusive_ptrconst-renf_class-makeconst-string-minpoly-const-string-gen-const-string-emb-slong-prec","text":"Return the number field obtained by adjoining the root of minpoly which is approximately emb . #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"2*x^4 - 4\", \"x\", \"1 +/- 1\");","title":"boost::intrusive_ptr&lt;const renf_class&gt; make(const string&amp; minpoly, const string&amp; gen, const string&amp; emb, slong prec)"},{"location":"doc_renf_class_hpp/#parameter-minpoly","text":"An irreducible polynomial in the variable gen . This minimal polynomial does not have to be totally real or monic.","title":"Parameter minpoly"},{"location":"doc_renf_class_hpp/#parameter-gen","text":"The name of the variable used in minpoly . Note that two fields that differ only in the name of the generator are treated as being distinct fields.","title":"Parameter gen"},{"location":"doc_renf_class_hpp/#parameter-emb","text":"An approximation of the root of minpoly . It makes no difference to what precision this approximation is provided but it must uniquely determine a single root of the polynomial.","title":"Parameter emb"},{"location":"doc_renf_class_hpp/#parameter-prec","text":"The default precision for all arithmetic. When performing arithmetic in this field, all operations are performed to that precision. When necessary, the precision is dynamically increased. This only affects the performance and inner workings of libeantic, the results of arithmetic operations and comparisons are not affected by this.","title":"Parameter prec"},{"location":"doc_renf_class_hpp/#boostintrusive_ptrconst-renf_class-makeconst-string-minpoly-const-string-gen-const-functionstring-slong-emb-slong-prec","text":"Return the number field obtained by adjoining the root of minpoly which is approximately emb . #include <e-antic/renf_class.hpp> #include <arb.h> #include <arf.h> const auto emb = [](slong prec) { arb_t emb; arb_init(emb); arb_sqrt_ui(emb, 2, prec); char* c_str = arb_get_str(emb, prec, ARB_STR_NO_RADIUS); std::string str(c_str); flint_free(c_str); arb_clear(emb); return str; }; auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", emb);","title":"boost::intrusive_ptr&lt;const renf_class&gt; make(const string&amp; minpoly, const string&amp; gen, const function&lt;string (slong)&gt; emb, slong prec)"},{"location":"doc_renf_class_hpp/#parameter-minpoly_1","text":"An irreducible polynomial in the variable gen . This minimal polynomial does not have to be totally real or monic.","title":"Parameter minpoly"},{"location":"doc_renf_class_hpp/#parameter-gen_1","text":"The name of the variable used in minpoly . Note that two fields that differ only in the name of the generator are treated as being distinct fields.","title":"Parameter gen"},{"location":"doc_renf_class_hpp/#parameter-emb_1","text":"Creates approximations of the root of minpoly that is suitable for computations with precision prec . It makes no difference to what precision this approximation is provided but it must for a sufficiently large value of prec uniquely determine a single root of the polynomial; with increasing prec it should converge to the actual root.","title":"Parameter emb"},{"location":"doc_renf_class_hpp/#parameter-prec_1","text":"The default precision for all arithmetic. When performing arithmetic in this field, all operations are performed to that precision. When necessary, the precision is dynamically increased. This only affects the performance and inner workings of libeantic, the results of arithmetic operations and comparisons are not affected by this.","title":"Parameter prec"},{"location":"doc_renf_class_hpp/#slong-degree-const","text":"Return the absolute degree of this number field.","title":"slong degree() const"},{"location":"doc_renf_class_hpp/#const-renf_elem_class-zero-const","text":"Return the zero element of this number field.","title":"const renf_elem_class&amp; zero() const"},{"location":"doc_renf_class_hpp/#const-renf_elem_class-one-const","text":"Return the one element of this number field.","title":"const renf_elem_class&amp; one() const"},{"location":"doc_renf_class_hpp/#const-renf_elem_class-gen-const","text":"Return the generator of this number field. #include <e-antic/renf_class.hpp> auto& K = eantic::renf_class::make(); std::cout << K.gen(); // -> 1 auto L = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.41 +/- 1\"); std::cout << L->gen(); // -> (x ~ 1.4142136)","title":"const renf_elem_class&amp; gen() const"},{"location":"doc_renf_class_hpp/#tuplestring-string-string-slong-construction-const","text":"Return the parameters (minpoly, gen, emb, prec) that can be used to construct this field with make . #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"2*x^4 - 4\", \"x\", \"1 +/- 1\"); auto construction = K->construction(); auto L = eantic::renf_class::make( std::get<0>(construction), std::get<1>(construction), std::get<2>(construction), std::get<3>(construction)); K == L // -> true","title":"tuple&lt;string, string, string, slong&gt; construction() const"},{"location":"doc_renf_class_hpp/#friend-bool-operatorconst-renf_class-const-renf_class","text":"Return whether two number fields are indistinguishable. #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1 +/- 1\"); auto L = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.41 +/- 0.1\"); K == L // -> true auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1 +/- 1\"); auto L = eantic::renf_class::make(\"2*x^2 - 4\", \"x\", \"1 +/- 1\"); K == L // -> false auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1 +/- 1\"); auto L = eantic::renf_class::make(\"y^2 - 2\", \"y\", \"1 +/- 1\"); K == L // -> false K != L // -> true","title":"friend bool operator==(const renf_class&amp;, const renf_class&amp;)"},{"location":"doc_renf_class_hpp/#const-string-gen_name-const","text":"Return the name of the generator of this field.","title":"const string&amp; gen_name() const"},{"location":"doc_renf_class_hpp/#string-to_string-const","text":"Return a human-readable representation of this field. #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"2*x^4 - 4\", \"x\", \"1 +/- 1\"); K->to_string() // -> NumberField(2*x^4 - 4, [1.18920711500272106671749997056 +/- 1.11e-30]) // There is also an operator<< which gives the same output. std::cout << *K; // -> NumberField(2*x^4 - 4, [1.18920711500272106671749997056 +/- 1.11e-30])","title":"string to_string() const"},{"location":"doc_renf_class_hpp/#friend-ostream-operatorostream-const-renf_class","text":"Write a human-readable representation of this field to the output stream.","title":"friend ostream&amp; operator&lt;&lt;(ostream&amp;, const renf_class&amp;)"},{"location":"doc_renf_class_hpp/#add_lvalue_reference_t-renf_t-renf_t-const","text":"Return the underlying renf_t . We do not return a const renf_t since calls in the C API might need to modify it (e.g., to refine the stored embedding) even though they are morally const.","title":"add_lvalue_reference_t&lt; ::renf_t&gt; renf_t() const"},{"location":"doc_renf_elem_class_hpp/","text":"renf_elem_class.hpp \u2014 Elements of Real Embedded Number Fields \u00b6 Class renf_elem_class \u00b6 An element of a Real Embedded Number Field. Each element lives in a fixed number field. If the number field is an extension of the rationals of degree $d$, its elements are represented by rational polynomials of degree $d - 1$. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto a = eantic::renf_elem_class(*K, std::vector{-1, 1}); std::cout << a; // -> (x-1 ~ 0.41421356) The underlying data can be accessed directly, e.g., with num_vector and den . Note that elements do not need to worry about the lifetime of the number field they are contained in. The number field will be kept alive by smart pointers as long as elements in it are around: #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto gen = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\")->gen(); std::cout << gen; // -> (x ~ 1.4142136) renf_elem_class() \u00b6 Create the zero element of the rationals. renf_elem_class(integer/rational) \u00b6 (1) renf_elem_class(int) (2) renf_elem_class(unsigned int) (3) renf_elem_class(long) (4) renf_elem_class(unsigned long) (5) renf_elem_class(long long) (6) renf_elem_class(unsigned long long) (7) renf_elem_class(const mpz_class&) (8) renf_elem_class(const fmpz_t) (9) renf_elem_class(const mpq_class&) (10) renf_elem_class(const fmpq_t) Create an element in the rationals. These are shortcuts equivalent to calling renf_elem_class(*renf_class::make(), value) . renf_elem_class(const renf_class& k) \u00b6 Create the zero element in the field k . renf_elem_class(const renf_class&, integer/rational) \u00b6 (1) renf_elem_class(const renf_class& k, int) (2) renf_elem_class(const renf_class& k, unsigned int) (3) renf_elem_class(const renf_class& k, long) (4) renf_elem_class(const renf_class& k, unsigned long) (5) renf_elem_class(const renf_class& k, long long) (6) renf_elem_class(const renf_class& k, unsigned long long) (7) renf_elem_class(const renf_class& k, const mpz_class&) (8) renf_elem_class(const renf_class& k, const fmpz_t) (9) renf_elem_class(const renf_class& k, const mpq_class&) (10) renf_elem_class(const renf_class& k, const fmpq_t) Create a rational element in the field k . renf_elem_class(const renf_class& k, const renf_elem_class&) \u00b6 Create an element in the field k from an existing element. This attempts to coerce the element into the field k . Currently, this is only implemented in trivial cases. renf_elem_class(const renf_class& k, const string&) \u00b6 Create an element in the field k from a string representation of its underlying polynomial. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); eantic::renf_elem_class(*K, \"x\") == K->gen() // -> true renf_elem_class(vector<integer/rational>) \u00b6 (1) renf_elem_class(const renf_class& k, const vector<int> &) (2) renf_elem_class(const renf_class& k, const vector<unsigned int> &) (3) renf_elem_class(const renf_class& k, const vector<long> &) (4) renf_elem_class(const renf_class& k, const vector<unsigned long> &) (5) renf_elem_class(const renf_class& k, const vector<mpz_class> &) (6) renf_elem_class(const renf_class& k, const vector<mpq_class> &) Create the element $\\sum c_i a^i$ where $a$ is the generator. The number of coefficients must not exceed the degree of the field. operator=(integer/rational) \u00b6 (1) renf_elem_class& operator=(int) (2) renf_elem_class& operator=(unsigned int) (3) renf_elem_class& operator=(long) (4) renf_elem_class& operator=(unsigned long) (5) renf_elem_class& operator=(long long) (6) renf_elem_class& operator=(unsigned long long) (7) renf_elem_class& operator=(const mpz_class&) (8) renf_elem_class& operator=(const mpq_class&) (9) renf_elem_class& operator=(const fmpz_t) (10) renf_elem_class& operator=(const fmpq_t) Reset this element to a rational number. The parent of the element is not preserved, i.e., it\u2019s always the rational field. To create a rational element in the number field, use the corresponding constructor. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto a = K->gen(); a.parent() == *K // -> true a = 1; a.parent() == *K // -> false a = eantic::renf_elem_class(*K, 1); a.parent() == *K // -> true operator=(number field element) \u00b6 (1) renf_elem_class& operator=(const renf_elem_class&) (2) renf_elem_class& operator=(renf_elem_class&&) Reset this element to another element. The parent of the element is not preserved, i.e., the resulting parent is always the parent of the argument. const renf_class& parent() const \u00b6 Return the containing number field. bool is_zero() const \u00b6 Return whether this element is the zero element in its field. bool is_one() const \u00b6 Return whether this element is the one element in its field. bool is_integer() const \u00b6 Return whether this element is a rational integer. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); K->gen().is_integer() // -> false K->one().is_integer() // -> true bool is_rational() const \u00b6 Return whether this element is a rational number. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); K->gen().is_rational() // -> false K->one().is_rational() // -> true mpz_class num() const \u00b6 Return the numerator of this element. The element must be rational for this to work, see num_content for non-rational elements. mpz_class den() const \u00b6 Return the denominator of this element. For non-rational elements, this returns the least common multiple of the denominators of the coefficients when written as $\\sum c_i a^i$ where $a$ is the field generator. operator mpz_class() const \u00b6 Convert this element to a GMP integer . The element must be an integer . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << static_cast<mpz_class>(K->one()); // -> 1 operator mpq_class() const \u00b6 Convert this element to a GMP rational number . The element must be a rational . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << static_cast<mpq_class>(K->one()); // -> 1 vector<mpz_class> num_vector() const \u00b6 Return the numerators of the coefficients of this element when written as $\\sum c_i a^i$ where $a$ is the field generator. string to_string() const \u00b6 (1) string to_string(int flags) const (2) operator std::string() const Return a string representation of this element. The optional flag of to_string() is passed on to renf_elem_get_str_pretty internally. Other than that, to_string() and the explicit string conversion are just aliases of each other: #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); K->gen().to_string() == static_cast<std::string>(K->gen()) // -> true mpz_class num_content() const \u00b6 Return the greatest common divisor of num_vector . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << (4*K->gen() + 2).num_content(); // -> 2 std::cout << K->zero().num_content(); // -> 0 mpz_class floor() const \u00b6 Return the integer floor of this element. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << K->gen().floor(); // -> 1 std::cout << (-K->gen()).floor(); // -> -2 mpz_class ceil() const \u00b6 Return the integer ceil of this element. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << K->gen().ceil(); // -> 2 std::cout << (-K->gen()).ceil(); // -> -1 int sgn() const \u00b6 Return the sign of this element. Returns one of -1 , 0 or +1 . operator double() const \u00b6 Return the double closest to this element. Ties are broken with ARF_RND_NEAR . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << static_cast<double>(K->gen()); // -> 1.41421 renf_elem_class operator-() const \u00b6 Return the negative of this element. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << -K->gen(); // -> (-x ~ -1.4142136) renf_elem_class operator+() const \u00b6 Return the positive of this element. Returns the element unchanged. operator bool() const \u00b6 Return whether this element is non-zero. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); bool(K->gen()) // -> true Arithmetic in the Number Field \u00b6 (1) renf_elem_class& operator+=(const renf_elem_class&) (2) renf_elem_class& operator-=(const renf_elem_class&) (3) renf_elem_class& operator*=(const renf_elem_class&) (4) renf_elem_class& operator/=(const renf_elem_class&) ELements in a number field support the usual arithmetic operators + , - , * , / . Internally, these operators are derived from the corresponding inplace operators += , -= , *= , /= . Note that arithmetic between elements in different number fields is currently only supported in trivial cases. Relational Operators \u00b6 (1) friend bool operator==(const renf_elem_class&, const renf_elem_class&) (2) friend bool operator<(const renf_elem_class&, const renf_elem_class&) Elements can be compared with the usual operators == , != , < , <= , >= , > . Internally, these operators are all derived from the definition of == and < . mpz_class floordiv(const renf_elem_class& rhs) const \u00b6 Return the integer floor of the division of this element by rhs . renf_elem_class pow(int exponent) const \u00b6 Return an integer power of this element. Arithmetic with Integers & Rationals \u00b6 (1) renf_elem_class& operator+=(int) (2) renf_elem_class& operator-=(int) (3) renf_elem_class& operator*=(int) (4) renf_elem_class& operator/=(int) (5) renf_elem_class& operator+=(unsigned int) (6) renf_elem_class& operator-=(unsigned int) (7) renf_elem_class& operator*=(unsigned int) (8) renf_elem_class& operator/=(unsigned int) (9) renf_elem_class& operator+=(long) (10) renf_elem_class& operator-=(long) (11) renf_elem_class& operator*=(long) (12) renf_elem_class& operator/=(long) (13) renf_elem_class& operator+=(unsigned long) (14) renf_elem_class& operator-=(unsigned long) (15) renf_elem_class& operator*=(unsigned long) (16) renf_elem_class& operator/=(unsigned long) (17) renf_elem_class& operator+=(long long) (18) renf_elem_class& operator-=(long long) (19) renf_elem_class& operator*=(long long) (20) renf_elem_class& operator/=(long long) (21) renf_elem_class& operator+=(unsigned long long) (22) renf_elem_class& operator-=(unsigned long long) (23) renf_elem_class& operator*=(unsigned long long) (24) renf_elem_class& operator/=(unsigned long long) (25) renf_elem_class& operator+=(const mpz_class&) (26) renf_elem_class& operator-=(const mpz_class&) (27) renf_elem_class& operator*=(const mpz_class&) (28) renf_elem_class& operator/=(const mpz_class&) (29) renf_elem_class& operator+=(const mpq_class&) (30) renf_elem_class& operator-=(const mpq_class&) (31) renf_elem_class& operator*=(const mpq_class&) (32) renf_elem_class& operator/=(const mpq_class&) Elements in a number field and integers/rationals can be combined with the usual arithmetic operators + , - , * , / and the corresponding inplace operators += , -= , *= , /= . Relational Operators with Integers & Rationals \u00b6 (1) friend bool operator==(const renf_elem_class&, int) (2) friend bool operator<(const renf_elem_class&, int) (3) friend bool operator>(const renf_elem_class&, int) (4) friend bool operator==(const renf_elem_class&, unsigned int) (5) friend bool operator<(const renf_elem_class&, unsigned int) (6) friend bool operator>(const renf_elem_class&, unsigned int) (7) friend bool operator==(const renf_elem_class&, long) (8) friend bool operator<(const renf_elem_class&, long) (9) friend bool operator>(const renf_elem_class&, long) (10) friend bool operator==(const renf_elem_class&, unsigned long) (11) friend bool operator<(const renf_elem_class&, unsigned long) (12) friend bool operator>(const renf_elem_class&, unsigned long) (13) friend bool operator==(const renf_elem_class&, long long) (14) friend bool operator<(const renf_elem_class&, long long) (15) friend bool operator>(const renf_elem_class&, long long) (16) friend bool operator==(const renf_elem_class&, unsigned long long) (17) friend bool operator<(const renf_elem_class&, unsigned long long) (18) friend bool operator>(const renf_elem_class&, unsigned long long) (19) friend bool operator==(const renf_elem_class&, const mpz_class&) (20) friend bool operator<(const renf_elem_class&, const mpz_class&) (21) friend bool operator>(const renf_elem_class&, const mpz_class&) (22) friend bool operator==(const renf_elem_class&, const mpq_class&) (23) friend bool operator<(const renf_elem_class&, const mpq_class&) (24) friend bool operator>(const renf_elem_class&, const mpq_class&) Elements in a number field and integers/rationals can be compared with the usual relational operators == , != , < , <= , >= , > . I/O \u00b6 (1) friend ostream& operator<<(ostream&, const renf_elem_class&) (2) friend istream& operator>>(istream&, renf_elem_class&) Elements can be written to streams and read from streams. However, reading non-rational elements from a stream is discouraged as it relies on the deprecated set_pword() method. #include <strstream> #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto a = K->gen(); std::strstream s; s << a; std::cout << s.str(); // -> (x ~ 1.4142136) s.seekp(0); // Before we can read from the stream, we must attach the number field to it. K->set_pword(s); s >> a; friend void swap(renf_elem_class& lhs, renf_elem_class& rhs) \u00b6 Efficiently swap two number field elements.","title":"renf_elem_class - number field elements"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classhpp-elements-of-real-embedded-number-fields","text":"","title":"renf\u000295\u0003elem\u000295\u0003class.hpp \u2014 Elements of Real Embedded Number Fields"},{"location":"doc_renf_elem_class_hpp/#class-renf_elem_class","text":"An element of a Real Embedded Number Field. Each element lives in a fixed number field. If the number field is an extension of the rationals of degree $d$, its elements are represented by rational polynomials of degree $d - 1$. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto a = eantic::renf_elem_class(*K, std::vector{-1, 1}); std::cout << a; // -> (x-1 ~ 0.41421356) The underlying data can be accessed directly, e.g., with num_vector and den . Note that elements do not need to worry about the lifetime of the number field they are contained in. The number field will be kept alive by smart pointers as long as elements in it are around: #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto gen = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\")->gen(); std::cout << gen; // -> (x ~ 1.4142136)","title":"Class renf_elem_class"},{"location":"doc_renf_elem_class_hpp/#renf_elem_class","text":"Create the zero element of the rationals.","title":"renf_elem_class()"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classintegerrational","text":"(1) renf_elem_class(int) (2) renf_elem_class(unsigned int) (3) renf_elem_class(long) (4) renf_elem_class(unsigned long) (5) renf_elem_class(long long) (6) renf_elem_class(unsigned long long) (7) renf_elem_class(const mpz_class&) (8) renf_elem_class(const fmpz_t) (9) renf_elem_class(const mpq_class&) (10) renf_elem_class(const fmpq_t) Create an element in the rationals. These are shortcuts equivalent to calling renf_elem_class(*renf_class::make(), value) .","title":"renf_elem_class(integer/rational)"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classconst-renf_class-k","text":"Create the zero element in the field k .","title":"renf_elem_class(const renf_class&amp; k)"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classconst-renf_class-integerrational","text":"(1) renf_elem_class(const renf_class& k, int) (2) renf_elem_class(const renf_class& k, unsigned int) (3) renf_elem_class(const renf_class& k, long) (4) renf_elem_class(const renf_class& k, unsigned long) (5) renf_elem_class(const renf_class& k, long long) (6) renf_elem_class(const renf_class& k, unsigned long long) (7) renf_elem_class(const renf_class& k, const mpz_class&) (8) renf_elem_class(const renf_class& k, const fmpz_t) (9) renf_elem_class(const renf_class& k, const mpq_class&) (10) renf_elem_class(const renf_class& k, const fmpq_t) Create a rational element in the field k .","title":"renf_elem_class(const renf_class&amp;, integer/rational)"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classconst-renf_class-k-const-renf_elem_class","text":"Create an element in the field k from an existing element. This attempts to coerce the element into the field k . Currently, this is only implemented in trivial cases.","title":"renf_elem_class(const renf_class&amp; k, const renf_elem_class&amp;)"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classconst-renf_class-k-const-string","text":"Create an element in the field k from a string representation of its underlying polynomial. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); eantic::renf_elem_class(*K, \"x\") == K->gen() // -> true","title":"renf_elem_class(const renf_class&amp; k, const string&amp;)"},{"location":"doc_renf_elem_class_hpp/#renf_elem_classvectorintegerrational","text":"(1) renf_elem_class(const renf_class& k, const vector<int> &) (2) renf_elem_class(const renf_class& k, const vector<unsigned int> &) (3) renf_elem_class(const renf_class& k, const vector<long> &) (4) renf_elem_class(const renf_class& k, const vector<unsigned long> &) (5) renf_elem_class(const renf_class& k, const vector<mpz_class> &) (6) renf_elem_class(const renf_class& k, const vector<mpq_class> &) Create the element $\\sum c_i a^i$ where $a$ is the generator. The number of coefficients must not exceed the degree of the field.","title":"renf_elem_class(vector&lt;integer/rational&gt;)"},{"location":"doc_renf_elem_class_hpp/#operatorintegerrational","text":"(1) renf_elem_class& operator=(int) (2) renf_elem_class& operator=(unsigned int) (3) renf_elem_class& operator=(long) (4) renf_elem_class& operator=(unsigned long) (5) renf_elem_class& operator=(long long) (6) renf_elem_class& operator=(unsigned long long) (7) renf_elem_class& operator=(const mpz_class&) (8) renf_elem_class& operator=(const mpq_class&) (9) renf_elem_class& operator=(const fmpz_t) (10) renf_elem_class& operator=(const fmpq_t) Reset this element to a rational number. The parent of the element is not preserved, i.e., it\u2019s always the rational field. To create a rational element in the number field, use the corresponding constructor. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto a = K->gen(); a.parent() == *K // -> true a = 1; a.parent() == *K // -> false a = eantic::renf_elem_class(*K, 1); a.parent() == *K // -> true","title":"operator=(integer/rational)"},{"location":"doc_renf_elem_class_hpp/#operatornumber-field-element","text":"(1) renf_elem_class& operator=(const renf_elem_class&) (2) renf_elem_class& operator=(renf_elem_class&&) Reset this element to another element. The parent of the element is not preserved, i.e., the resulting parent is always the parent of the argument.","title":"operator=(number field element)"},{"location":"doc_renf_elem_class_hpp/#const-renf_class-parent-const","text":"Return the containing number field.","title":"const renf_class&amp; parent() const"},{"location":"doc_renf_elem_class_hpp/#bool-is_zero-const","text":"Return whether this element is the zero element in its field.","title":"bool is_zero() const"},{"location":"doc_renf_elem_class_hpp/#bool-is_one-const","text":"Return whether this element is the one element in its field.","title":"bool is_one() const"},{"location":"doc_renf_elem_class_hpp/#bool-is_integer-const","text":"Return whether this element is a rational integer. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); K->gen().is_integer() // -> false K->one().is_integer() // -> true","title":"bool is_integer() const"},{"location":"doc_renf_elem_class_hpp/#bool-is_rational-const","text":"Return whether this element is a rational number. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); K->gen().is_rational() // -> false K->one().is_rational() // -> true","title":"bool is_rational() const"},{"location":"doc_renf_elem_class_hpp/#mpz_class-num-const","text":"Return the numerator of this element. The element must be rational for this to work, see num_content for non-rational elements.","title":"mpz_class num() const"},{"location":"doc_renf_elem_class_hpp/#mpz_class-den-const","text":"Return the denominator of this element. For non-rational elements, this returns the least common multiple of the denominators of the coefficients when written as $\\sum c_i a^i$ where $a$ is the field generator.","title":"mpz_class den() const"},{"location":"doc_renf_elem_class_hpp/#operator-mpz_class-const","text":"Convert this element to a GMP integer . The element must be an integer . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << static_cast<mpz_class>(K->one()); // -> 1","title":"operator mpz_class() const"},{"location":"doc_renf_elem_class_hpp/#operator-mpq_class-const","text":"Convert this element to a GMP rational number . The element must be a rational . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << static_cast<mpq_class>(K->one()); // -> 1","title":"operator mpq_class() const"},{"location":"doc_renf_elem_class_hpp/#vectormpz_class-num_vector-const","text":"Return the numerators of the coefficients of this element when written as $\\sum c_i a^i$ where $a$ is the field generator.","title":"vector&lt;mpz_class&gt; num_vector() const"},{"location":"doc_renf_elem_class_hpp/#string-to_string-const","text":"(1) string to_string(int flags) const (2) operator std::string() const Return a string representation of this element. The optional flag of to_string() is passed on to renf_elem_get_str_pretty internally. Other than that, to_string() and the explicit string conversion are just aliases of each other: #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); K->gen().to_string() == static_cast<std::string>(K->gen()) // -> true","title":"string to_string() const"},{"location":"doc_renf_elem_class_hpp/#mpz_class-num_content-const","text":"Return the greatest common divisor of num_vector . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << (4*K->gen() + 2).num_content(); // -> 2 std::cout << K->zero().num_content(); // -> 0","title":"mpz_class num_content() const"},{"location":"doc_renf_elem_class_hpp/#mpz_class-floor-const","text":"Return the integer floor of this element. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << K->gen().floor(); // -> 1 std::cout << (-K->gen()).floor(); // -> -2","title":"mpz_class floor() const"},{"location":"doc_renf_elem_class_hpp/#mpz_class-ceil-const","text":"Return the integer ceil of this element. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << K->gen().ceil(); // -> 2 std::cout << (-K->gen()).ceil(); // -> -1","title":"mpz_class ceil() const"},{"location":"doc_renf_elem_class_hpp/#int-sgn-const","text":"Return the sign of this element. Returns one of -1 , 0 or +1 .","title":"int sgn() const"},{"location":"doc_renf_elem_class_hpp/#operator-double-const","text":"Return the double closest to this element. Ties are broken with ARF_RND_NEAR . #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << static_cast<double>(K->gen()); // -> 1.41421","title":"operator double() const"},{"location":"doc_renf_elem_class_hpp/#renf_elem_class-operator-const","text":"Return the negative of this element. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); std::cout << -K->gen(); // -> (-x ~ -1.4142136)","title":"renf_elem_class operator-() const"},{"location":"doc_renf_elem_class_hpp/#renf_elem_class-operator-const_1","text":"Return the positive of this element. Returns the element unchanged.","title":"renf_elem_class operator+() const"},{"location":"doc_renf_elem_class_hpp/#operator-bool-const","text":"Return whether this element is non-zero. #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); bool(K->gen()) // -> true","title":"operator bool() const"},{"location":"doc_renf_elem_class_hpp/#arithmetic-in-the-number-field","text":"(1) renf_elem_class& operator+=(const renf_elem_class&) (2) renf_elem_class& operator-=(const renf_elem_class&) (3) renf_elem_class& operator*=(const renf_elem_class&) (4) renf_elem_class& operator/=(const renf_elem_class&) ELements in a number field support the usual arithmetic operators + , - , * , / . Internally, these operators are derived from the corresponding inplace operators += , -= , *= , /= . Note that arithmetic between elements in different number fields is currently only supported in trivial cases.","title":"Arithmetic in the Number Field"},{"location":"doc_renf_elem_class_hpp/#relational-operators","text":"(1) friend bool operator==(const renf_elem_class&, const renf_elem_class&) (2) friend bool operator<(const renf_elem_class&, const renf_elem_class&) Elements can be compared with the usual operators == , != , < , <= , >= , > . Internally, these operators are all derived from the definition of == and < .","title":"Relational Operators"},{"location":"doc_renf_elem_class_hpp/#mpz_class-floordivconst-renf_elem_class-rhs-const","text":"Return the integer floor of the division of this element by rhs .","title":"mpz_class floordiv(const renf_elem_class&amp; rhs) const"},{"location":"doc_renf_elem_class_hpp/#renf_elem_class-powint-exponent-const","text":"Return an integer power of this element.","title":"renf_elem_class pow(int exponent) const"},{"location":"doc_renf_elem_class_hpp/#arithmetic-with-integers-rationals","text":"(1) renf_elem_class& operator+=(int) (2) renf_elem_class& operator-=(int) (3) renf_elem_class& operator*=(int) (4) renf_elem_class& operator/=(int) (5) renf_elem_class& operator+=(unsigned int) (6) renf_elem_class& operator-=(unsigned int) (7) renf_elem_class& operator*=(unsigned int) (8) renf_elem_class& operator/=(unsigned int) (9) renf_elem_class& operator+=(long) (10) renf_elem_class& operator-=(long) (11) renf_elem_class& operator*=(long) (12) renf_elem_class& operator/=(long) (13) renf_elem_class& operator+=(unsigned long) (14) renf_elem_class& operator-=(unsigned long) (15) renf_elem_class& operator*=(unsigned long) (16) renf_elem_class& operator/=(unsigned long) (17) renf_elem_class& operator+=(long long) (18) renf_elem_class& operator-=(long long) (19) renf_elem_class& operator*=(long long) (20) renf_elem_class& operator/=(long long) (21) renf_elem_class& operator+=(unsigned long long) (22) renf_elem_class& operator-=(unsigned long long) (23) renf_elem_class& operator*=(unsigned long long) (24) renf_elem_class& operator/=(unsigned long long) (25) renf_elem_class& operator+=(const mpz_class&) (26) renf_elem_class& operator-=(const mpz_class&) (27) renf_elem_class& operator*=(const mpz_class&) (28) renf_elem_class& operator/=(const mpz_class&) (29) renf_elem_class& operator+=(const mpq_class&) (30) renf_elem_class& operator-=(const mpq_class&) (31) renf_elem_class& operator*=(const mpq_class&) (32) renf_elem_class& operator/=(const mpq_class&) Elements in a number field and integers/rationals can be combined with the usual arithmetic operators + , - , * , / and the corresponding inplace operators += , -= , *= , /= .","title":"Arithmetic with Integers &amp; Rationals"},{"location":"doc_renf_elem_class_hpp/#relational-operators-with-integers-rationals","text":"(1) friend bool operator==(const renf_elem_class&, int) (2) friend bool operator<(const renf_elem_class&, int) (3) friend bool operator>(const renf_elem_class&, int) (4) friend bool operator==(const renf_elem_class&, unsigned int) (5) friend bool operator<(const renf_elem_class&, unsigned int) (6) friend bool operator>(const renf_elem_class&, unsigned int) (7) friend bool operator==(const renf_elem_class&, long) (8) friend bool operator<(const renf_elem_class&, long) (9) friend bool operator>(const renf_elem_class&, long) (10) friend bool operator==(const renf_elem_class&, unsigned long) (11) friend bool operator<(const renf_elem_class&, unsigned long) (12) friend bool operator>(const renf_elem_class&, unsigned long) (13) friend bool operator==(const renf_elem_class&, long long) (14) friend bool operator<(const renf_elem_class&, long long) (15) friend bool operator>(const renf_elem_class&, long long) (16) friend bool operator==(const renf_elem_class&, unsigned long long) (17) friend bool operator<(const renf_elem_class&, unsigned long long) (18) friend bool operator>(const renf_elem_class&, unsigned long long) (19) friend bool operator==(const renf_elem_class&, const mpz_class&) (20) friend bool operator<(const renf_elem_class&, const mpz_class&) (21) friend bool operator>(const renf_elem_class&, const mpz_class&) (22) friend bool operator==(const renf_elem_class&, const mpq_class&) (23) friend bool operator<(const renf_elem_class&, const mpq_class&) (24) friend bool operator>(const renf_elem_class&, const mpq_class&) Elements in a number field and integers/rationals can be compared with the usual relational operators == , != , < , <= , >= , > .","title":"Relational Operators with Integers &amp; Rationals"},{"location":"doc_renf_elem_class_hpp/#io","text":"(1) friend ostream& operator<<(ostream&, const renf_elem_class&) (2) friend istream& operator>>(istream&, renf_elem_class&) Elements can be written to streams and read from streams. However, reading non-rational elements from a stream is discouraged as it relies on the deprecated set_pword() method. #include <strstream> #include <e-antic/renf_class.hpp> #include <e-antic/renf_elem_class.hpp> auto K = eantic::renf_class::make(\"x^2 - 2\", \"x\", \"1.4 +/- 1\"); auto a = K->gen(); std::strstream s; s << a; std::cout << s.str(); // -> (x ~ 1.4142136) s.seekp(0); // Before we can read from the stream, we must attach the number field to it. K->set_pword(s); s >> a;","title":"I/O"},{"location":"doc_renf_elem_class_hpp/#friend-void-swaprenf_elem_class-lhs-renf_elem_class-rhs","text":"Efficiently swap two number field elements.","title":"friend void swap(renf_elem_class&amp; lhs, renf_elem_class&amp; rhs)"},{"location":"doc_renf_elem_h/","text":"renf_elem.h \u2014 Embedded number field elements \u00b6 Memory Layout \u00b6 Struct renf_elem \u00b6 struct renf_elem{ nf_elem_t elem; arb_t emb; }; A real embedded number field element Member Variable elem \u00b6 An algebraic ANTIC number field element. Member Variable emb \u00b6 An approximation of the embedded element as a real ball . Type Alias renf_elem_t \u00b6 An element of a real embedded number field. Actually, this is an array of renf_elem of length one. Typically, users of e-antic should not worry about the exact definition of this and just treat this as the type that represents a number field element in e-antic. See the documentation of renf_t for why this is an array. void renf_elem_init(renf_elem_t a, const renf_t nf) \u00b6 Initialize the number field element a . This function has to be called prior to any code using a as it performs allocation. Once done with a the memory must be freed with renf_elem_clear . void renf_elem_clear(renf_elem_t a, const renf_t nf) \u00b6 Deallocate the memory for a that was allocated with renf_elem_init . void renf_elem_swap(renf_elem_t a, renf_elem_t b) \u00b6 Swap the number field elements a and b Setters \u00b6 void renf_elem_zero(renf_elem_t a, const renf_t nf) \u00b6 Set the number field element a to zero. void renf_elem_one(renf_elem_t a, const renf_t nf) \u00b6 Set the number field element a to one. void renf_elem_gen(renf_elem_t a, const renf_t nf) \u00b6 Set the number field element a to the generator of the number field. Integer/Rational Setters \u00b6 (1) void renf_elem_set_si(renf_elem_t a, slong n, const renf_t nf) (2) void renf_elem_set_ui(renf_elem_t a, mp_limb_t n, const renf_t nf) (3) void renf_elem_set_nf_elem(renf_elem_t a, const nf_elem_t b, renf_t nf, slong prec) (4) void renf_elem_set(renf_elem_t a, const renf_elem_t b, const renf_t nf) (5) void renf_elem_set_fmpz(renf_elem_t a, const fmpz_t c, const renf_t nf) (6) void renf_elem_set_mpz(renf_elem_t a, const mpz_t c, const renf_t nf) (7) void renf_elem_set_fmpq(renf_elem_t a, const fmpq_t c, const renf_t nf) (8) void renf_elem_set_mpq(renf_elem_t a, const mpq_t c, const renf_t nf) (9) void renf_elem_set_fmpq_poly(renf_elem_t a, const fmpq_poly_t pol, const renf_t nf) Set a to provided integer/rational as an element in the number field nf . Embedding refinement \u00b6 void renf_elem_set_evaluation(renf_elem_t a, const renf_t nf, slong prec) \u00b6 Set the enclosure of the number field element a using the enclosure of the generator of nf . Computation is done at precision prec . This function does not make any refinement of the number field generator. For that purpose see renf_refine_embedding . Properties and conversion \u00b6 int renf_elem_is_zero(const renf_elem_t a, const renf_t nf) \u00b6 Return 1 if a is equal to zero and 0 otherwise. int renf_elem_is_one(const renf_elem_t a, const renf_t nf) \u00b6 Return 1 if a is equal to one and 0 otherwise. int renf_elem_is_integer(const renf_elem_t a, const renf_t nf) \u00b6 Return 1 if a is integral and 0 otherwise. int renf_elem_is_rational(const renf_elem_t a, const renf_t nf) \u00b6 Return 1 if a is rational and 0 otherwise. int renf_elem_sgn(renf_elem_t a, renf_t nf) \u00b6 Return the sign of a . It is 1 if a is positive, 0 if a is zero and -1 if a is negative. void renf_elem_floor(fmpz_t a, renf_elem_t b, renf_t nf) \u00b6 Set a to be the floor of b void renf_elem_ceil(fmpz_t a, renf_elem_t b, renf_t nf) \u00b6 Set a to be the ceil of b Floating point approximations \u00b6 void renf_elem_get_arb(arb_t x, renf_elem_t a, renf_t nf, slong prec) \u00b6 Set x to a a real ball enclosing the element a that belongs to the number field nf with prec bits of precision. double renf_elem_get_d(renf_elem_t a, renf_t nf, int rnd) \u00b6 Return a double approximation. Comparisons \u00b6 (1) int renf_elem_cmp(renf_elem_t a, renf_elem_t b, renf_t nf) (2) int _renf_elem_cmp_fmpq(renf_elem_t a, fmpz* num, fmpz* den, renf_t nf) (3) int renf_elem_cmp_fmpq(renf_elem_t a, const fmpq_t b, renf_t nf) (4) int renf_elem_cmp_fmpz(renf_elem_t a, const fmpz_t b, renf_t nf) (5) int renf_elem_cmp_si(renf_elem_t a, const slong b, renf_t nf) (6) int renf_elem_cmp_ui(renf_elem_t a, const mp_limb_t b, renf_t nf) (7) int renf_elem_equal(const renf_elem_t a, const renf_elem_t b, const renf_t nf) (8) int renf_elem_equal_si(const renf_elem_t a, const slong b, const renf_t nf) (9) int renf_elem_equal_ui(const renf_elem_t a, const mp_limb_t b, const renf_t nf) (10) int renf_elem_equal_fmpz(const renf_elem_t a, const fmpz_t b, const renf_t nf) (11) int renf_elem_equal_fmpq(const renf_elem_t a, const fmpq_t b, const renf_t nf) All the comparison functions renf_elem_cmp_\u2026 between two elements a and b behave as follows. They return a positive integer if a is greater than b , 0 if a and b are equal, and a negative integer if a is smaller than b . If you want to check for equality, use the faster renf_elem_equal_\u2026 functions. String Conversion and Printing \u00b6 char* renf_elem_get_str_pretty(renf_elem_t a, char* var, renf_t nf, slong n, int flag) \u00b6 Return a as a string with variable name var . The resulting string needs to be freed with flint_free . void renf_elem_print_pretty(renf_elem_t a, char* var, renf_t nf, slong n, int flag) \u00b6 Write a to the standard output. Randomization \u00b6 void renf_elem_randtest(renf_elem_t a, flint_rand_t state, ulong bits, renf_t nf) \u00b6 Set a to a random element in nf . Unary operations \u00b6 void renf_elem_neg(renf_elem_t a, const renf_elem_t b, const renf_t nf) \u00b6 Set a to the negative of b . void renf_elem_inv(renf_elem_t a, const renf_elem_t b, const renf_t nf) \u00b6 Set a to the inverse of b . Binary operations \u00b6 void renf_elem_add_si(renf_elem_t a, const renf_elem_t b, slong c, const renf_t nf) \u00b6 All the binary operation functions are of the form renf_elem_OP_TYP(a, b, c, nf) where OP is the operation type TYP is the type of the argument c a is the argument used for returned value b and c are the operands nf is the parent number field of the operation In short, these functions perform a = b OP c . void renf_elem_fdiv(fmpz_t a, renf_elem_t b, renf_elem_t c, renf_t nf) \u00b6 Perform the floor division of the number field elements b and c and set the result in a . The result is equivalent to a call of [renf_elem_div] followed by [renf_elem_floor]. This function is much faster, though. Other functions \u00b6 slong renf_elem_get_cfrac(fmpz* c, renf_elem_t rem, renf_elem_t a, slong n, renf_t nf) \u00b6 Set the array c to the n -th first partial quotients of the continued fraction of the element a of nf . void renf_elem_check_embedding(const renf_elem_t a, const renf_t nf, slong prec) \u00b6 Check that the embedding is consistent. int renf_elem_relative_condition_number_2exp(slong* cond, renf_elem_t a, renf_t nf) \u00b6 Logarithm of the condition number of a . The return value corresponds to the number of bits of precision that will be lost when evaluating a as a polynomial in the number field generator.","title":"renf_elem \u2014 number field elements"},{"location":"doc_renf_elem_h/#renf_elemh-embedded-number-field-elements","text":"","title":"renf\u000295\u0003elem.h \u2014 Embedded number field elements"},{"location":"doc_renf_elem_h/#memory-layout","text":"","title":"Memory Layout"},{"location":"doc_renf_elem_h/#struct-renf_elem","text":"struct renf_elem{ nf_elem_t elem; arb_t emb; }; A real embedded number field element","title":"Struct renf_elem"},{"location":"doc_renf_elem_h/#member-variable-elem","text":"An algebraic ANTIC number field element.","title":"Member Variable elem"},{"location":"doc_renf_elem_h/#member-variable-emb","text":"An approximation of the embedded element as a real ball .","title":"Member Variable emb"},{"location":"doc_renf_elem_h/#type-alias-renf_elem_t","text":"An element of a real embedded number field. Actually, this is an array of renf_elem of length one. Typically, users of e-antic should not worry about the exact definition of this and just treat this as the type that represents a number field element in e-antic. See the documentation of renf_t for why this is an array.","title":"Type Alias renf_elem_t"},{"location":"doc_renf_elem_h/#void-renf_elem_initrenf_elem_t-a-const-renf_t-nf","text":"Initialize the number field element a . This function has to be called prior to any code using a as it performs allocation. Once done with a the memory must be freed with renf_elem_clear .","title":"void renf_elem_init(renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_clearrenf_elem_t-a-const-renf_t-nf","text":"Deallocate the memory for a that was allocated with renf_elem_init .","title":"void renf_elem_clear(renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_swaprenf_elem_t-a-renf_elem_t-b","text":"Swap the number field elements a and b","title":"void renf_elem_swap(renf_elem_t a, renf_elem_t b)"},{"location":"doc_renf_elem_h/#setters","text":"","title":"Setters"},{"location":"doc_renf_elem_h/#void-renf_elem_zerorenf_elem_t-a-const-renf_t-nf","text":"Set the number field element a to zero.","title":"void renf_elem_zero(renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_onerenf_elem_t-a-const-renf_t-nf","text":"Set the number field element a to one.","title":"void renf_elem_one(renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_genrenf_elem_t-a-const-renf_t-nf","text":"Set the number field element a to the generator of the number field.","title":"void renf_elem_gen(renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#integerrational-setters","text":"(1) void renf_elem_set_si(renf_elem_t a, slong n, const renf_t nf) (2) void renf_elem_set_ui(renf_elem_t a, mp_limb_t n, const renf_t nf) (3) void renf_elem_set_nf_elem(renf_elem_t a, const nf_elem_t b, renf_t nf, slong prec) (4) void renf_elem_set(renf_elem_t a, const renf_elem_t b, const renf_t nf) (5) void renf_elem_set_fmpz(renf_elem_t a, const fmpz_t c, const renf_t nf) (6) void renf_elem_set_mpz(renf_elem_t a, const mpz_t c, const renf_t nf) (7) void renf_elem_set_fmpq(renf_elem_t a, const fmpq_t c, const renf_t nf) (8) void renf_elem_set_mpq(renf_elem_t a, const mpq_t c, const renf_t nf) (9) void renf_elem_set_fmpq_poly(renf_elem_t a, const fmpq_poly_t pol, const renf_t nf) Set a to provided integer/rational as an element in the number field nf .","title":"Integer/Rational Setters"},{"location":"doc_renf_elem_h/#embedding-refinement","text":"","title":"Embedding refinement"},{"location":"doc_renf_elem_h/#void-renf_elem_set_evaluationrenf_elem_t-a-const-renf_t-nf-slong-prec","text":"Set the enclosure of the number field element a using the enclosure of the generator of nf . Computation is done at precision prec . This function does not make any refinement of the number field generator. For that purpose see renf_refine_embedding .","title":"void renf_elem_set_evaluation(renf_elem_t a, const renf_t nf, slong prec)"},{"location":"doc_renf_elem_h/#properties-and-conversion","text":"","title":"Properties and conversion"},{"location":"doc_renf_elem_h/#int-renf_elem_is_zeroconst-renf_elem_t-a-const-renf_t-nf","text":"Return 1 if a is equal to zero and 0 otherwise.","title":"int renf_elem_is_zero(const renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#int-renf_elem_is_oneconst-renf_elem_t-a-const-renf_t-nf","text":"Return 1 if a is equal to one and 0 otherwise.","title":"int renf_elem_is_one(const renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#int-renf_elem_is_integerconst-renf_elem_t-a-const-renf_t-nf","text":"Return 1 if a is integral and 0 otherwise.","title":"int renf_elem_is_integer(const renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#int-renf_elem_is_rationalconst-renf_elem_t-a-const-renf_t-nf","text":"Return 1 if a is rational and 0 otherwise.","title":"int renf_elem_is_rational(const renf_elem_t a, const renf_t nf)"},{"location":"doc_renf_elem_h/#int-renf_elem_sgnrenf_elem_t-a-renf_t-nf","text":"Return the sign of a . It is 1 if a is positive, 0 if a is zero and -1 if a is negative.","title":"int renf_elem_sgn(renf_elem_t a, renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_floorfmpz_t-a-renf_elem_t-b-renf_t-nf","text":"Set a to be the floor of b","title":"void renf_elem_floor(fmpz_t a, renf_elem_t b, renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_ceilfmpz_t-a-renf_elem_t-b-renf_t-nf","text":"Set a to be the ceil of b","title":"void renf_elem_ceil(fmpz_t a, renf_elem_t b, renf_t nf)"},{"location":"doc_renf_elem_h/#floating-point-approximations","text":"","title":"Floating point approximations"},{"location":"doc_renf_elem_h/#void-renf_elem_get_arbarb_t-x-renf_elem_t-a-renf_t-nf-slong-prec","text":"Set x to a a real ball enclosing the element a that belongs to the number field nf with prec bits of precision.","title":"void renf_elem_get_arb(arb_t x, renf_elem_t a, renf_t nf, slong prec)"},{"location":"doc_renf_elem_h/#double-renf_elem_get_drenf_elem_t-a-renf_t-nf-int-rnd","text":"Return a double approximation.","title":"double renf_elem_get_d(renf_elem_t a, renf_t nf, int rnd)"},{"location":"doc_renf_elem_h/#comparisons","text":"(1) int renf_elem_cmp(renf_elem_t a, renf_elem_t b, renf_t nf) (2) int _renf_elem_cmp_fmpq(renf_elem_t a, fmpz* num, fmpz* den, renf_t nf) (3) int renf_elem_cmp_fmpq(renf_elem_t a, const fmpq_t b, renf_t nf) (4) int renf_elem_cmp_fmpz(renf_elem_t a, const fmpz_t b, renf_t nf) (5) int renf_elem_cmp_si(renf_elem_t a, const slong b, renf_t nf) (6) int renf_elem_cmp_ui(renf_elem_t a, const mp_limb_t b, renf_t nf) (7) int renf_elem_equal(const renf_elem_t a, const renf_elem_t b, const renf_t nf) (8) int renf_elem_equal_si(const renf_elem_t a, const slong b, const renf_t nf) (9) int renf_elem_equal_ui(const renf_elem_t a, const mp_limb_t b, const renf_t nf) (10) int renf_elem_equal_fmpz(const renf_elem_t a, const fmpz_t b, const renf_t nf) (11) int renf_elem_equal_fmpq(const renf_elem_t a, const fmpq_t b, const renf_t nf) All the comparison functions renf_elem_cmp_\u2026 between two elements a and b behave as follows. They return a positive integer if a is greater than b , 0 if a and b are equal, and a negative integer if a is smaller than b . If you want to check for equality, use the faster renf_elem_equal_\u2026 functions.","title":"Comparisons"},{"location":"doc_renf_elem_h/#string-conversion-and-printing","text":"","title":"String Conversion and Printing"},{"location":"doc_renf_elem_h/#char-renf_elem_get_str_prettyrenf_elem_t-a-char-var-renf_t-nf-slong-n-int-flag","text":"Return a as a string with variable name var . The resulting string needs to be freed with flint_free .","title":"char* renf_elem_get_str_pretty(renf_elem_t a, char* var, renf_t nf, slong n, int flag)"},{"location":"doc_renf_elem_h/#void-renf_elem_print_prettyrenf_elem_t-a-char-var-renf_t-nf-slong-n-int-flag","text":"Write a to the standard output.","title":"void renf_elem_print_pretty(renf_elem_t a, char* var, renf_t nf, slong n, int flag)"},{"location":"doc_renf_elem_h/#randomization","text":"","title":"Randomization"},{"location":"doc_renf_elem_h/#void-renf_elem_randtestrenf_elem_t-a-flint_rand_t-state-ulong-bits-renf_t-nf","text":"Set a to a random element in nf .","title":"void renf_elem_randtest(renf_elem_t a, flint_rand_t state, ulong bits, renf_t nf)"},{"location":"doc_renf_elem_h/#unary-operations","text":"","title":"Unary operations"},{"location":"doc_renf_elem_h/#void-renf_elem_negrenf_elem_t-a-const-renf_elem_t-b-const-renf_t-nf","text":"Set a to the negative of b .","title":"void renf_elem_neg(renf_elem_t a, const renf_elem_t b, const renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_invrenf_elem_t-a-const-renf_elem_t-b-const-renf_t-nf","text":"Set a to the inverse of b .","title":"void renf_elem_inv(renf_elem_t a, const renf_elem_t b, const renf_t nf)"},{"location":"doc_renf_elem_h/#binary-operations","text":"","title":"Binary operations"},{"location":"doc_renf_elem_h/#void-renf_elem_add_sirenf_elem_t-a-const-renf_elem_t-b-slong-c-const-renf_t-nf","text":"All the binary operation functions are of the form renf_elem_OP_TYP(a, b, c, nf) where OP is the operation type TYP is the type of the argument c a is the argument used for returned value b and c are the operands nf is the parent number field of the operation In short, these functions perform a = b OP c .","title":"void renf_elem_add_si(renf_elem_t a, const renf_elem_t b, slong c, const renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_fdivfmpz_t-a-renf_elem_t-b-renf_elem_t-c-renf_t-nf","text":"Perform the floor division of the number field elements b and c and set the result in a . The result is equivalent to a call of [renf_elem_div] followed by [renf_elem_floor]. This function is much faster, though.","title":"void renf_elem_fdiv(fmpz_t a, renf_elem_t b, renf_elem_t c, renf_t nf)"},{"location":"doc_renf_elem_h/#other-functions","text":"","title":"Other functions"},{"location":"doc_renf_elem_h/#slong-renf_elem_get_cfracfmpz-c-renf_elem_t-rem-renf_elem_t-a-slong-n-renf_t-nf","text":"Set the array c to the n -th first partial quotients of the continued fraction of the element a of nf .","title":"slong renf_elem_get_cfrac(fmpz* c, renf_elem_t rem, renf_elem_t a, slong n, renf_t nf)"},{"location":"doc_renf_elem_h/#void-renf_elem_check_embeddingconst-renf_elem_t-a-const-renf_t-nf-slong-prec","text":"Check that the embedding is consistent.","title":"void renf_elem_check_embedding(const renf_elem_t a, const renf_t nf, slong prec)"},{"location":"doc_renf_elem_h/#int-renf_elem_relative_condition_number_2expslong-cond-renf_elem_t-a-renf_t-nf","text":"Logarithm of the condition number of a . The return value corresponds to the number of bits of precision that will be lost when evaluating a as a polynomial in the number field generator.","title":"int renf_elem_relative_condition_number_2exp(slong* cond, renf_elem_t a, renf_t nf)"},{"location":"doc_renf_h/","text":"renf.h \u2014 Real Embedded Number Fields \u00b6 This header defines one of the basic objects of e-antic, renf_t a real embedded number field and the functions that interact with it. Memory Layout \u00b6 Struct renf \u00b6 struct renf{ nf_t nf; fmpz_poly_t der; mp_limb_signed_t prec; arb_t emb; int immutable; }; Internal representation of a real embedded number field. The attributes are not part of the API and should be accessed directly. The exact structure here is only of interest for those who want to work on e-antic itself. To interact with a real embedded number field, use the renf_ functions described below. Typical users of e-antic will never instantiate a renf directly but instead work with a renf_t . Member Variable nf \u00b6 An algebraic number field, provided by ANTIC. Member Variable der \u00b6 The derivative of the defining polynomial (without denominator) as a FLINT polynomial over the integers. Member Variable prec \u00b6 Precision (number of bits) used for binary operations on enclosures. Member Variable emb \u00b6 The real embeddeding of the generator of this number field, given as ball in the reals. Member Variable immutable \u00b6 A flag used during refinements to ensure thread-safety. Type Alias renf_t \u00b6 A real embedded number field. Actually, this is an array of renf of length one. Typically, users of e-antic should not worry about the exact definition of this and just treat this as the type that represents a number field in e-antic. Using an array of length one instead of a plain renf or a renf* is a common trick in C which is probably best known from MPFR and GMP but also used in the FLINT and Arb libraries that we build upon. Essentially, this gives much better semantics than a plain renf . E.g., a renf_t is not assignable. (Directly assigning a renf to another renf does not do what one would expect as the heap-allocated parts of a renf are not duplicated correctly.) Also, calling a function that accepts a renf_t passes the value with reference semantics, as if it were a renf* , i.e., without copying the underlying value. Since a renf_t is always stack allocated and cannot be returned from a function, it is also much harder to produce dangling pointers which one would get when using renf* everywhere instead. Initialization, Allocation, Deallocation \u00b6 void renf_init(renf_t nf, fmpq_poly_t pol, arb_t emb, slong prec) \u00b6 Set nf to be the real embedded number field define by the minimal polynomial pol and the (approximate) embedding emb . The parameter prec is used as the default precision for binary operations on enclosures. void renf_init_nth_root_fmpq(renf_t nf, fmpq_t d, mp_limb_t n, slong prec) \u00b6 Set nf to be the real embedded number field defined as the n -th root of the rational number d . prec is the default precision. void renf_init_set(renf_t dest, const renf_t src) \u00b6 Copy src to dest . void renf_clear(renf_t nf) \u00b6 Deallocate the number field nf originally allocated with one of the renf_init above. slong renf_set_embeddings_fmpz_poly(renf* nf, fmpz_poly_t pol, slong lim, slong prec) \u00b6 Set the lim first elements of the array nf to the real embeddings of the irreducible polynomial pol . Each number field is initialized with a default prec of bit precision for binary operations. Other Functions \u00b6 void renf_refine_embedding(renf_t nf, slong prec) \u00b6 Refine the embedding of nf to prec bits of precision. int renf_set_immutable(renf_t nf, int immutable) \u00b6 Change the mutability of the number field. If immutable is zero, make the number field mutable. Otherwise, make the number field immutable. Returns the previous value. It is not possible to refine the embedding of an immutable number field. This method is used internally as a sanity-check in multi-threaded code. int renf_equal(const renf_t nf1, const renf_t nf2) \u00b6 Return whether the two number fields are equal. Two embedded number field are considered equal if they define the same subfield of the real numbers. The precision of the embedding or the precision of bit operations do not matter in this comparison. slong renf_degree(renf_t nf) \u00b6 Return the degree of the number field. void renf_randtest(renf_t nf, flint_rand_t state, slong len, slong prec, ulong bits) \u00b6 Set nf to a random number field. Used internally in unit tests. char* renf_get_str(const renf_t nf, char* var, slong prec) \u00b6 Return a printable representation of this number field. Returns a C string which uses var as the name of the variable and the precision is given with prec bits. The returned string has to be deallocated with flint_free after usage. void renf_print(const renf_t nf) \u00b6 Print the number field on the standard output.","title":"renf \u2014 number fields"},{"location":"doc_renf_h/#renfh-real-embedded-number-fields","text":"This header defines one of the basic objects of e-antic, renf_t a real embedded number field and the functions that interact with it.","title":"renf.h \u2014 Real Embedded Number Fields"},{"location":"doc_renf_h/#memory-layout","text":"","title":"Memory Layout"},{"location":"doc_renf_h/#struct-renf","text":"struct renf{ nf_t nf; fmpz_poly_t der; mp_limb_signed_t prec; arb_t emb; int immutable; }; Internal representation of a real embedded number field. The attributes are not part of the API and should be accessed directly. The exact structure here is only of interest for those who want to work on e-antic itself. To interact with a real embedded number field, use the renf_ functions described below. Typical users of e-antic will never instantiate a renf directly but instead work with a renf_t .","title":"Struct renf"},{"location":"doc_renf_h/#member-variable-nf","text":"An algebraic number field, provided by ANTIC.","title":"Member Variable nf"},{"location":"doc_renf_h/#member-variable-der","text":"The derivative of the defining polynomial (without denominator) as a FLINT polynomial over the integers.","title":"Member Variable der"},{"location":"doc_renf_h/#member-variable-prec","text":"Precision (number of bits) used for binary operations on enclosures.","title":"Member Variable prec"},{"location":"doc_renf_h/#member-variable-emb","text":"The real embeddeding of the generator of this number field, given as ball in the reals.","title":"Member Variable emb"},{"location":"doc_renf_h/#member-variable-immutable","text":"A flag used during refinements to ensure thread-safety.","title":"Member Variable immutable"},{"location":"doc_renf_h/#type-alias-renf_t","text":"A real embedded number field. Actually, this is an array of renf of length one. Typically, users of e-antic should not worry about the exact definition of this and just treat this as the type that represents a number field in e-antic. Using an array of length one instead of a plain renf or a renf* is a common trick in C which is probably best known from MPFR and GMP but also used in the FLINT and Arb libraries that we build upon. Essentially, this gives much better semantics than a plain renf . E.g., a renf_t is not assignable. (Directly assigning a renf to another renf does not do what one would expect as the heap-allocated parts of a renf are not duplicated correctly.) Also, calling a function that accepts a renf_t passes the value with reference semantics, as if it were a renf* , i.e., without copying the underlying value. Since a renf_t is always stack allocated and cannot be returned from a function, it is also much harder to produce dangling pointers which one would get when using renf* everywhere instead.","title":"Type Alias renf_t"},{"location":"doc_renf_h/#initialization-allocation-deallocation","text":"","title":"Initialization, Allocation, Deallocation"},{"location":"doc_renf_h/#void-renf_initrenf_t-nf-fmpq_poly_t-pol-arb_t-emb-slong-prec","text":"Set nf to be the real embedded number field define by the minimal polynomial pol and the (approximate) embedding emb . The parameter prec is used as the default precision for binary operations on enclosures.","title":"void renf_init(renf_t nf, fmpq_poly_t pol, arb_t emb, slong prec)"},{"location":"doc_renf_h/#void-renf_init_nth_root_fmpqrenf_t-nf-fmpq_t-d-mp_limb_t-n-slong-prec","text":"Set nf to be the real embedded number field defined as the n -th root of the rational number d . prec is the default precision.","title":"void renf_init_nth_root_fmpq(renf_t nf, fmpq_t d, mp_limb_t n, slong prec)"},{"location":"doc_renf_h/#void-renf_init_setrenf_t-dest-const-renf_t-src","text":"Copy src to dest .","title":"void renf_init_set(renf_t dest, const renf_t src)"},{"location":"doc_renf_h/#void-renf_clearrenf_t-nf","text":"Deallocate the number field nf originally allocated with one of the renf_init above.","title":"void renf_clear(renf_t nf)"},{"location":"doc_renf_h/#slong-renf_set_embeddings_fmpz_polyrenf-nf-fmpz_poly_t-pol-slong-lim-slong-prec","text":"Set the lim first elements of the array nf to the real embeddings of the irreducible polynomial pol . Each number field is initialized with a default prec of bit precision for binary operations.","title":"slong renf_set_embeddings_fmpz_poly(renf* nf, fmpz_poly_t pol, slong lim, slong prec)"},{"location":"doc_renf_h/#other-functions","text":"","title":"Other Functions"},{"location":"doc_renf_h/#void-renf_refine_embeddingrenf_t-nf-slong-prec","text":"Refine the embedding of nf to prec bits of precision.","title":"void renf_refine_embedding(renf_t nf, slong prec)"},{"location":"doc_renf_h/#int-renf_set_immutablerenf_t-nf-int-immutable","text":"Change the mutability of the number field. If immutable is zero, make the number field mutable. Otherwise, make the number field immutable. Returns the previous value. It is not possible to refine the embedding of an immutable number field. This method is used internally as a sanity-check in multi-threaded code.","title":"int renf_set_immutable(renf_t nf, int immutable)"},{"location":"doc_renf_h/#int-renf_equalconst-renf_t-nf1-const-renf_t-nf2","text":"Return whether the two number fields are equal. Two embedded number field are considered equal if they define the same subfield of the real numbers. The precision of the embedding or the precision of bit operations do not matter in this comparison.","title":"int renf_equal(const renf_t nf1, const renf_t nf2)"},{"location":"doc_renf_h/#slong-renf_degreerenf_t-nf","text":"Return the degree of the number field.","title":"slong renf_degree(renf_t nf)"},{"location":"doc_renf_h/#void-renf_randtestrenf_t-nf-flint_rand_t-state-slong-len-slong-prec-ulong-bits","text":"Set nf to a random number field. Used internally in unit tests.","title":"void renf_randtest(renf_t nf, flint_rand_t state, slong len, slong prec, ulong bits)"},{"location":"doc_renf_h/#char-renf_get_strconst-renf_t-nf-char-var-slong-prec","text":"Return a printable representation of this number field. Returns a C string which uses var as the name of the variable and the precision is given with prec bits. The returned string has to be deallocated with flint_free after usage.","title":"char* renf_get_str(const renf_t nf, char* var, slong prec)"},{"location":"doc_renf_h/#void-renf_printconst-renf_t-nf","text":"Print the number field on the standard output.","title":"void renf_print(const renf_t nf)"},{"location":"doc_renfxx_fwd_hpp/","text":"renfxx_fwd.hpp \u00b6","title":"renfxx\\_fwd.hpp"},{"location":"doc_renfxx_fwd_hpp/#renfxx_fwdhpp","text":"","title":"renfxx\u000295\u0003fwd.hpp"},{"location":"doc_renfxx_h/","text":"renfxx.h \u00b6","title":"renfxx.h"},{"location":"doc_renfxx_h/#renfxxh","text":"","title":"renfxx.h"},{"location":"install_in_conda/","text":"Install e-antic in Conda \u00b6 You can install this package with conda. Download and install mambaforge , and then create an environment with conda-forge\u2019s distribution of e-antic installed mamba create -n eantic libeantic pyeantic mamba activate eantic","title":"Install e-antic in Conda"},{"location":"install_in_conda/#install-e-antic-in-conda","text":"You can install this package with conda. Download and install mambaforge , and then create an environment with conda-forge\u2019s distribution of e-antic installed mamba create -n eantic libeantic pyeantic mamba activate eantic","title":"Install e-antic in Conda"},{"location":"overview_c/","text":"Overview of the C interface \u00b6 There are two main objects in e-antic. Number fields, which are represented by a renf_t , and their elements, represented by a renf_elem_t . Functions that operate on number fields are defined in the header e-antic/renf.h and have the prefix renf_ . Functions that operate on elements of number fields are defined in the header e-antic/renf_elem.h and have the prefix renf_elem_ . To work with e-antic, you first need to create a number field. Typically, you will use the function renf_init to create a number field from its defining rational polynomial as a FLINT fmpq_poly_t and an approximation of one of its real roots as an arb_t . Once a renf_t has been initialized, its elements can be created with renf_elem_init . Eventually, use renf_elem_clear to free the memory taken by these elements, and use renf_clear to free the memory taken by the number field itself. Example \u00b6 We want to construct a totally real field with minimal polynomial $x^3 - 3x + 1$, represented by an fmpq_poly_t . We include the appropriate headers and define the polynomial. #include <e-antic/fmpq_poly_extra.h> fmpq_poly_t poly; fmpq_poly_init(poly); fmpq_poly_set_str_pretty(poly, \"a^3 - 3*a + 1\", \"a\"); We fix one of its roots which is approximately 0.34. #include <arb.h> arb_t emb; arb_init(emb); arb_set_str(emb, \"0.34 +/- 0.01\", 32); We construct the embedded number field and let $a$ be its generator. #include <e-antic/renf.h> #include <e-antic/renf_elem.h> renf_t nf; renf_elem_t a, b; /* initialize and set the real ball emb to approximately 0.34 */ arb_init(emb); arb_set_str(emb, \"0.34 +/- 0.01\", 32); renf_init(nf, poly, emb, 64); renf_elem_init(a, nf); renf_elem_gen(a, nf); We deallocate the embedding and the defining polynomial, as we will no longer need them. fmpq_poly_clear(poly); arb_clear(emb); We compute $b = a^2 - 2$ and print its value. renf_elem_init(b, nf); renf_elem_mul(b, a, a, nf); renf_elem_sub_ui(b, b, 2, nf); renf_elem_print_pretty(b, \"a\", nf, 32, EANTIC_STR_ALG); // -> a^2 - 2 Finally, we deallocate the number field and its elements. renf_elem_clear(a, nf); renf_elem_clear(b, nf); renf_clear(nf);","title":"Overview"},{"location":"overview_c/#overview-of-the-c-interface","text":"There are two main objects in e-antic. Number fields, which are represented by a renf_t , and their elements, represented by a renf_elem_t . Functions that operate on number fields are defined in the header e-antic/renf.h and have the prefix renf_ . Functions that operate on elements of number fields are defined in the header e-antic/renf_elem.h and have the prefix renf_elem_ . To work with e-antic, you first need to create a number field. Typically, you will use the function renf_init to create a number field from its defining rational polynomial as a FLINT fmpq_poly_t and an approximation of one of its real roots as an arb_t . Once a renf_t has been initialized, its elements can be created with renf_elem_init . Eventually, use renf_elem_clear to free the memory taken by these elements, and use renf_clear to free the memory taken by the number field itself.","title":"Overview of the C interface"},{"location":"overview_c/#example","text":"We want to construct a totally real field with minimal polynomial $x^3 - 3x + 1$, represented by an fmpq_poly_t . We include the appropriate headers and define the polynomial. #include <e-antic/fmpq_poly_extra.h> fmpq_poly_t poly; fmpq_poly_init(poly); fmpq_poly_set_str_pretty(poly, \"a^3 - 3*a + 1\", \"a\"); We fix one of its roots which is approximately 0.34. #include <arb.h> arb_t emb; arb_init(emb); arb_set_str(emb, \"0.34 +/- 0.01\", 32); We construct the embedded number field and let $a$ be its generator. #include <e-antic/renf.h> #include <e-antic/renf_elem.h> renf_t nf; renf_elem_t a, b; /* initialize and set the real ball emb to approximately 0.34 */ arb_init(emb); arb_set_str(emb, \"0.34 +/- 0.01\", 32); renf_init(nf, poly, emb, 64); renf_elem_init(a, nf); renf_elem_gen(a, nf); We deallocate the embedding and the defining polynomial, as we will no longer need them. fmpq_poly_clear(poly); arb_clear(emb); We compute $b = a^2 - 2$ and print its value. renf_elem_init(b, nf); renf_elem_mul(b, a, a, nf); renf_elem_sub_ui(b, b, 2, nf); renf_elem_print_pretty(b, \"a\", nf, 32, EANTIC_STR_ALG); // -> a^2 - 2 Finally, we deallocate the number field and its elements. renf_elem_clear(a, nf); renf_elem_clear(b, nf); renf_clear(nf);","title":"Example"},{"location":"overview_cxx/","text":"Overview of the C++ interface \u00b6 There are two main objects in e-antic. Number fields, which are represented by a eantic::renf_class , and their elements, represented by a eantic::renf_elem_class . These objects are provided by the headers e-antic/renf_class.hpp and e-antic/renf_elem_class.hpp respectively. To work with e-antic, you first need to create a number field. Typically, by providing a minimal polynomial and an approximation of one of its roots. Once a eantic::renf_class has been initialized, its elements can be created with the various eantic::renf_elem_class contructors. Lifetime of all these objects is taken care of by smart pointers, so you usually do not need to worry about allocating and freeing resources manually. Example \u00b6 We construct a totally real field with minimal polynomial $x^3 - 3x + 1$ and fix its real root which is approximately 0.34. #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"x^3 - 3*x + 1\", \"x\", \"0.34 +/- .01\"); Let a be the selected root of this number field: #include <e-antic/renf_elem_class.hpp> auto a = K->gen(); We compute $b = a^2 - 2$ and print its value. auto b = a.pow(2) - 2; std::cout << b; // -> (x^2 - 2 ~ -1.8793852) Note that the same example is also explained in detail in the documentation of the C interface .","title":"Overview"},{"location":"overview_cxx/#overview-of-the-c-interface","text":"There are two main objects in e-antic. Number fields, which are represented by a eantic::renf_class , and their elements, represented by a eantic::renf_elem_class . These objects are provided by the headers e-antic/renf_class.hpp and e-antic/renf_elem_class.hpp respectively. To work with e-antic, you first need to create a number field. Typically, by providing a minimal polynomial and an approximation of one of its roots. Once a eantic::renf_class has been initialized, its elements can be created with the various eantic::renf_elem_class contructors. Lifetime of all these objects is taken care of by smart pointers, so you usually do not need to worry about allocating and freeing resources manually.","title":"Overview of the C++ interface"},{"location":"overview_cxx/#example","text":"We construct a totally real field with minimal polynomial $x^3 - 3x + 1$ and fix its real root which is approximately 0.34. #include <e-antic/renf_class.hpp> auto K = eantic::renf_class::make(\"x^3 - 3*x + 1\", \"x\", \"0.34 +/- .01\"); Let a be the selected root of this number field: #include <e-antic/renf_elem_class.hpp> auto a = K->gen(); We compute $b = a^2 - 2$ and print its value. auto b = a.pow(2) - 2; std::cout << b; // -> (x^2 - 2 ~ -1.8793852) Note that the same example is also explained in detail in the documentation of the C interface .","title":"Example"}]}